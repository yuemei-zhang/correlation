.sass-cache/
*.css.map



data das.basic;
set policy.tmp_xq_das_new_1;
run;

data das.basic;
set das.basic(where=( borrow_type in (6,8)));
run;


data das.das_value;
set policy.tmp_xq_das_new;
run;

data das.das_value;
set das.das_value(drop = id addtime);
run;

/*先获得频数*/
proc contents data= das.das_value_freq  out=das.test_struct_freq noprint;
run;

data das.das_value_freq;
set das.das_value(drop=user_id borrow_nid company_name);
run;

%macro freq_var(varname=);
proc freq data=das.das_value_freq(keep =&varname.) noprint;
table &varname. /missing out=das.b&varname ;
run;

data das.b&varname;
length label $100.;
length value $100.;
set das.b&varname.;
label="&varname.";
value=&varname.;
drop &varname.;
run;

proc append base=das.result_freq 
		                           data=das.b&varname force;
								   run;
proc delete data=das.b&varname;
run;
%mend;


data _null_;
set das.test_struct_freq end=last;
call execute('%freq_var(varname='||strip(name)||' );');

	run;

/*先把use_mobile_2_cnt_1y 和 sns_pii 这两个字段中的“#”替换掉*/

data das.das_value;
set das.das_value;
if use_mobile_2_cnt_1y='#' then use_mobile_2_cnt_1y=.;
if sns_pii='#' then sns_pii=.;
run;

proc contents data= das.das_value out=das.test_struct noprint; 
run;

data das.test_struct;
set das.test_struct end=last;
where type=2;
retain k;
k+1;
keep name k;
if name ne 'borrow_nid';
if name ne 'user_id';
if find(name , 'status')=0;
if name ne 'company_name';
if name ne 'occupation';

run;
/*将数值转换成文本*/
option compress=yes;
%macro a(varname=, id=);
%let var=%sysfunc(cats(&varname,_new));
%if &id=1 %then %do;
data  das.das_value_1 ;
set  das.das_value;
&var=&varname*1;
drop &varname;
run;
%end;

%if &id>1 %then %do;
data das.das_value_1;
set das.das_value_1;
&var=&varname*1;
drop &varname;
run;
%end;

%mend;

data _null_;
set das.test_struct end=last;
call execute('%a(varname='||strip(name)||' , id='||k||');');

	run;


/*DAS b表和借款表匹配*/
proc sort data=das.das_value_1;
by user_id borrow_nid;

proc sort data=das.basic;
by user_id borrow_nid;

run;

data das.basic_das_borrow;
merge das.basic(in=a) das.das_value_1(in=b);
by user_id borrow_nid;
if a=1;
run;

data das.basic_das_borrow_1;
set  das.basic_das_borrow(where =(borrow_type=6)); run;

proc contents data= das.basic_das_borrow  varnum;
run;

proc means data=das.basic_das_borrow_1;
class last_1y_total_active_biz_cnt_new;
var is_due is_late is_due_5 is_late_5 is_due_10 is_late_10;
output out=last_1y_total_active_biz_cnt_new  sum=sum_due sum_late sum_due_5 sum_late_5 sum_due_10 sum_late_10;
run;


/*分组输出*/
	
%MACRO  cxq(varname=,borrow_type=);

  data table;
  set das.basic_das_borrow(where=(borrow_type=&borrow_type.));
  keep user_id  borrow_nid borrow_type   is_due is_late is_due_5 is_late_5 is_due_10 is_late_10   &varname.;
  run;

  proc sort data=table;
  by borrow_nid;
  run;

		PROC RANK DATA=table(where=( &varname. >1) ) GROUPS=8  OUT=temp_ds_bin;
		VAR &varname. ;
		RANKS Bin;
		RUN;
							
			data temp_ds_bin_1;
			set temp_ds_bin;
			if bin=. or  &varname.<0 then bin=1;
			else bin=bin+2;
			run;

   proc sort data=temp_ds_bin_1;
   by borrow_nid;

   data temp_ds_bin;
   merge table temp_ds_bin_1;
   by borrow_nid;
   if bin=. and  &varname. =. then bin=0;
   if bin=. and &varname.=1 then bin=1;
   run;


			
			/*get the range for each of the bin;*/
			PROC SQL NOPRINT;
					CREATE TABLE temp_bin_limits AS
					SELECT Bin, MIN(&varname.) AS Bin_LowerLimit, MAX(&varname.) AS Bin_UpperLimit 
						FROM temp_ds_bin
						GROUP BY Bin
						ORDER BY Bin;						
			QUIT;
			
			*calculate the 'Event' and 'NonEvent' count for each of the bin;
			PROC SORT DATA=temp_ds_bin(KEEP =is_due is_late is_due_5 is_late_5 is_due_10 is_late_10  &varname. Bin) OUT=temp_bin_smry;
					BY Bin;
			RUN;
			
			DATA temp_bin_smry;
					SET temp_bin_smry;
					BY Bin;
					
					*initialize;
					IF FIRST.Bin THEN DO;
							total_due = .;
							total_is_late=.;
							total_is_due_5= .;	
							total_is_late_5= .;	
							total_is_due_10= .;	
							total_is_late_10= .;	
	
							
							
					END;
					
						total_due+is_due ;
						total_is_late+is_late;
						total_is_due_5+is_due_5;	
						total_is_late_5+is_late_5;	
						total_is_due_10+is_due_10;	
						total_is_late_10+ is_late_10;	

					if last.bin then output;
					
					DROP  is_due is_late is_due_5 is_late_5 is_due_10 is_late_10  &varname.;
			RUN;			
			
		*merge the min/max with the cross tabulation;					
		DATA b_&varname.;
			length var $200.;
			var="&varname.";
			MERGE temp_bin_smry
						temp_bin_limits;
			BY Bin;
		

		RUN;

		proc append base=das.result&borrow_type.
		                           data=b_&varname. force;
								   run;

  proc delete data=b_&varname.;run;
		%mend;
proc contents data= das.das_value_1 out=das.test_struct_final noprint; 
run;

data das.test_struct_final;
set das.test_struct_final end=last;
where find(name,'new')>0;

run;

		data _null_;
set  das.test_struct_final;

call execute('%cxq(varname='||strip(name)||', borrow_type=6);');
/*if type="char" then call execute('%cxq_char(varname='||strip(name)||');');*/

		run;

				data _null_;
set mysas.test_struct_1;

call execute('%cxq(varname='||strip(name)||', borrow_type=8);');
/*if type="char" then call execute('%cxq_char(varname='||strip(name)||');');*/

		run;
option obs=max;
/*字符变量*/
data struct;

input label $200. @@;


cards;

ovd_order_cnt_12m_m3_status
ovd_order_cnt_12m_m6_status 
ovd_order_cnt_2y_m3_status 
ovd_order_cnt_2y_m6_status 
ovd_order_cnt_3m_m1_status 
ovd_order_cnt_5y_m3_status 
ovd_order_cnt_5y_m6_status 
ovd_order_cnt_6m_m1_status 
occupation 
;

run;


%macro cxq_char(varname=, borrow_type=);
proc means data = das.basic_das_borrow(where=(borrow_type=&borrow_type.)) noprint;
class &varname.;
var is_due is_late is_due_5 is_late_5 is_due_10 is_late_10;
output out=&varname. sum=sum_due sum_late sum_due_5 sum_late_5 sum_due_10 sum_late_10;

data &varname.;
set &varname.;
length var_name $100.;
varname="&varname.";
var_name=&varname.;
drop &varname.;
run;
proc append base=result_char data=&varname. force;
run;
%mend;


data _null_;
set struct;

call execute('%cxq_char(varname='||strip(label)||', borrow_type=6);');

run;

proc means data= das.basic_das_borrow(where=(borrow_type=6));
var is_due is_late is_due_5 is_late_5 is_due_10 is_late_10;
output out=total sum=sum_due sum_late sum_due_5 sum_late_5 sum_due_10 sum_late_10;
run;


/*spm*/
data das.spm_v2;
set das.basic_das_borrow;
if borrow_type=6 and is_due_10 =1;
array a _character_;
array b _numeric_;
do i=1 to dim(a);
if missing(a[i]) then a[i]='missing';
end;
do i=1 to dim(b);
if missing(b[i]) then b[i]= -1;
end;

if is_late_10=1 then is_good=0;
else if is_late_10=0 then is_good=1;


run;

data das.spm_v3;

set das.spm_v2 ;
drop   USER_ID   BORROW_NID  BORROW_TYPE   STATUS  ADD_TIME      ACCOUNT   IS_DUE      IS_LATE    IS_DUE_5    IS_LATE_5    IS_DUE_10          IS_LATE_10
COMPANY_NAME;
run;


proc corr data




data das.spm_analysis;
set das.basic_das_borrow;
if borrow_type=6;


/*Rules for terminal node 39*/

if
(
    POSITIVE_BIZ_CNT_1Y_NEW > 2.50000 &&
    AUTH_FIN_LAST_1M_CNT_NEW > 4.50000 &&
    CREDIT_PAY_MONTHS_1Y_NEW <= 5.50000 &&
    HAVE_CAR_FLAG_NEW > 2.50000 
) 
then node_39=1 ;
else node_39=0;





/*Rules for terminal node 4*/

if
(
    ADR_STABILITY_DAYS_NEW <= 2.50000 &&
    TOT_PAY_AMT_1M_NEW > 2.50000 &&
    AUTH_FIN_LAST_1M_CNT_NEW <= 4.50000 &&
    LAST_6M_AVG_ASSET_TOTAL_NEW <= 2.50000 &&
    POSITIVE_BIZ_CNT_1Y_NEW <= 1.50000 &&
    MOBILE_FIXED_DAYS_NEW <= 5.50000 &&
    LAST_1Y_AVG_ASSET_TOTAL_NEW > 2.50000 
)
then node_4=1 ;
else node_4=0;



/*Rules for terminal node 11*/

if
(
    ADR_STABILITY_DAYS_NEW <= 2.50000 &&
    TOT_PAY_AMT_1M_NEW > 2.50000 &&
    AUTH_FIN_LAST_1M_CNT_NEW <= 4.50000 &&
    LAST_6M_AVG_ASSET_TOTAL_NEW <= 2.50000 &&
    POSITIVE_BIZ_CNT_1Y_NEW > 1.50000 &&
    POSITIVE_BIZ_CNT_1Y_NEW <= 2.50000 &&
    CREDIT_PAY_MONTHS_1Y_NEW > 8.50000 
)
then node_11=1 ;
else node_11=0;



/*Rules for terminal node 20*/

if
(
    POSITIVE_BIZ_CNT_1Y_NEW <= 2.50000 &&
    ADR_STABILITY_DAYS_NEW <= 2.50000 &&
    TOT_PAY_AMT_1M_NEW > 2.50000 &&
    AUTH_FIN_LAST_1M_CNT_NEW <= 4.50000 &&
    LAST_6M_AVG_ASSET_TOTAL_NEW > 2.50000 &&
    CREDIT_TOTAL_PAY_MONTHS_NEW <= 3.50000 &&
    LAST_1Y_AVG_ASSET_TOTAL_NEW <= 5.50000 &&
    EBILL_PAY_AMT_6M_NEW > 10.50000 
)
then node_20=1 ;
else node_20=0;



/*Rules for terminal node 30*/

if
(
    POSITIVE_BIZ_CNT_1Y_NEW <= 2.50000 &&
    EBILL_PAY_AMT_6M_NEW <= 3.50000 &&
    MOBILE_FIXED_DAYS_NEW > 3.50000 &&
    ADR_STABILITY_DAYS_NEW > 7.50000 
)

then node_30=1 ;
else node_30=0;


/*Rules for terminal node 32*/

if
(
    POSITIVE_BIZ_CNT_1Y_NEW > 2.50000 &&
    AUTH_FIN_LAST_1M_CNT_NEW <= 4.50000 &&
    OVD_ORDER_AMT_6M_NEW <= 1.50000 
)

then node_32=1 ;
else node_32=0;

run;


data struct;

input label $200. @@;


cards;
node_39
node_4
node_11
node_20
node_30
node_32
;

run;

%let input=node_39
node_4
node_11
node_20
node_30
node_32;


%macro cxq_char(varname=);
proc means data = das.spm_analysis  noprint;
class &varname.;
var is_due is_late is_due_5 is_late_5 is_due_10 is_late_10;
output out=&varname. sum=sum_due sum_late sum_due_5 sum_late_5 sum_due_10 sum_late_10;

data b_&varname.;
set &varname.;
length var_name $100.;
var_name="&varname.";
varname=&varname.;

drop &varname.;
where _type_=1;
run;
proc append base=das.result_char data=b_&varname. force;
run;
%mend;
	
data _null_;
set struct;

call execute('%cxq_char(varname='||strip(label)||');');

run;



data das.basic_das_borrow_corr;
merge das.basic(in=a) das.das_value_1(in=b);
by user_id borrow_nid;
if b=1 & a=1;
run;

data das.spm_v_last;

set das.basic_das_borrow_corr;
if borrow_type=6 and is_due_10 =1;
if is_late_10=1 then is_good=0;
else if is_late_10=0 then is_good=1;

drop   USER_ID   BORROW_NID  BORROW_TYPE   STATUS  ADD_TIME      ACCOUNT   IS_DUE      IS_LATE    IS_DUE_5    IS_LATE_5    IS_DUE_10          IS_LATE_10
COMPANY_NAME;

run;



data das.spm_v4;
set das.basic_das_borrow_corr;
if borrow_type=6 and is_due_10 =1;
array a _character_;
array b _numeric_;
do i=1 to dim(a);
if missing(a[i]) then a[i]='missing';
end;
do i=1 to dim(b);
if missing(b[i]) then b[i]=- 1;
end;

if is_late_10=1 then is_good=0;
else if is_late_10=0 then is_good=1;


run;


data das.spm_v5;
set das.spm_v4;
drop   USER_ID   BORROW_NID  BORROW_TYPE   STATUS  ADD_TIME      ACCOUNT   IS_DUE      IS_LATE    IS_DUE_5    IS_LATE_5    IS_DUE_10          IS_LATE_10
COMPANY_NAME;

run;

ods html;

proc contents data=das.spm_v5  varnum;

run;


proc contents data=das.spm_v5 out=das.spm_corr_varlist noprint;
run;


proc corr data=das.spm_v5 noprint out=das.Cov(where=(_type_="CORR"));
var activity_area_stability_new
adr_stability_days_new
auth_fin_last_1m_cnt_new
auth_fin_last_3m_cnt_new
auth_fin_last_6m_cnt_new
avg_puc_sdm_last_1y_new
avgdomesticdiscount_new
consume_steady_byxs_1y_new
credit_duration_new
credit_pay_amt_1m_new
credit_pay_amt_1y_new
credit_pay_amt_3m_new
credit_pay_amt_6m_new
credit_pay_months_1y_new
credit_total_pay_months_new
domesticbuscount_new
domesticfirstcount_new
ebill_pay_amt_1m_new
ebill_pay_amt_3m_new
ebill_pay_amt_6m_new
flightcount_new
flightintercount_new
have_car_flag_new
have_fang_flag_new
last_1m_avg_asset_total_new
last_1y_avg_asset_total_new
last_1y_total_active_biz_cnt_new
last_3m_avg_asset_total_new
last_6m_avg_asset_total_new
mobile_fixed_days_new
ovd_order_amt_12m_new
ovd_order_amt_1m_new
ovd_order_amt_3m_new
ovd_order_amt_6m_new
ovd_order_cnt_12m_new
ovd_order_cnt_1m_new
ovd_order_cnt_3m_new
ovd_order_cnt_6m_new
positive_biz_cnt_1y_new
pre_1y_pay_amount_new
pre_1y_pay_cnt_new
relevant_stability_new
sns_pii_new
tot_pay_amt_1m_new
tot_pay_amt_3m_new
tot_pay_amt_6m_new
use_mobile_2_cnt_1y_new
xfdc_index_new;

run;

%let inputs=activity_area_stability_new
adr_stability_days_new
auth_fin_last_1m_cnt_new
auth_fin_last_3m_cnt_new
auth_fin_last_6m_cnt_new
avg_puc_sdm_last_1y_new
consume_steady_byxs_1y_new
credit_duration_new
credit_pay_amt_1m_new
credit_pay_amt_1y_new
credit_pay_amt_3m_new
credit_pay_amt_6m_new
credit_pay_months_1y_new
credit_total_pay_months_new
ebill_pay_amt_1m_new
ebill_pay_amt_3m_new
ebill_pay_amt_6m_new
have_car_flag_new
have_fang_flag_new
last_1m_avg_asset_total_new
last_1y_avg_asset_total_new
last_1y_total_active_biz_cnt_new
last_3m_avg_asset_total_new
last_6m_avg_asset_total_new
mobile_fixed_days_new
ovd_order_amt_12m_new
ovd_order_amt_1m_new
ovd_order_amt_3m_new
ovd_order_amt_6m_new
ovd_order_cnt_12m_new
ovd_order_cnt_1m_new
ovd_order_cnt_3m_new
ovd_order_cnt_6m_new
positive_biz_cnt_1y_new
pre_1y_pay_amount_new
pre_1y_pay_cnt_new
relevant_stability_new
sns_pii_new
tot_pay_amt_1m_new
tot_pay_amt_3m_new
tot_pay_amt_6m_new
use_mobile_2_cnt_1y_new
xfdc_index_new;

%put &inputs;

proc varclus data=das.spm_v5 (drop = i is_good)
                                    maxeigen=.7
									outtree=fortree
									short;
				var &inputs;
				run;


/*尝试双变量*/
data das.das_double_var;
set das.spm_v4 (drop = i);

if POSITIVE_BIZ_CNT_1Y_NEW  >= 2.50000    then node1=1 ; else node1=0;
if CREDIT_PAY_MONTHS_1Y_NEW  >= 3.50000    then node2=1 ; else node2=0;
if CREDIT_TOTAL_PAY_MONTHS_NEW  >= 3.50000    then node3=1 ; else node3=0;
if CREDIT_PAY_AMT_6M_NEW  >= 1.50000    then node4=1 ; else node4=0;
if ADR_STABILITY_DAYS_NEW  >= 2.50000    then node5=1 ; else node5=0;
if CREDIT_PAY_AMT_3M_NEW  >= 1.50000    then node6=1 ; else node6=0;
if CREDIT_PAY_AMT_1Y_NEW  >= 1.50000    then node7=1 ; else node7=0;
if EBILL_PAY_AMT_6M_NEW  >= 3.50000    then node8=1 ; else node8=0;
if TOT_PAY_AMT_6M_NEW  >= 2.50000    then node9=1 ; else node9=0;
if EBILL_PAY_AMT_3M_NEW  >= 3.50000    then node10=1 ; else node10=0;
if CREDIT_DURATION_NEW  >= 2.50000    then node11=1 ; else node11=0;
if RELEVANT_STABILITY_NEW  >= 3.50000    then node12=1 ; else node12=0;
if TOT_PAY_AMT_3M_NEW  >= 2.50000    then node13=1 ; else node13=0;
if EBILL_PAY_AMT_1M_NEW  >= 3.50000    then node14=1 ; else node14=0;
if LAST_1Y_TOTAL_ACTIVE_BIZ_CNT_NEW  >= 7.50000    then node15=1 ; else node15=0;
if TOT_PAY_AMT_1M_NEW  >= 2.50000    then node16=1 ; else node16=0;
if LAST_6M_AVG_ASSET_TOTAL_NEW  >= 2.50000    then node17=1 ; else node17=0;
if CREDIT_PAY_AMT_1M_NEW  >= 1.50000    then node18=1 ; else node18=0;
if LAST_1Y_AVG_ASSET_TOTAL_NEW  >= 2.50000    then node19=1 ; else node19=0;
if SNS_PII_NEW  >= 1.50000    then node20=1 ; else node20=0;
if PRE_1Y_PAY_AMOUNT_NEW  >= 3.50000    then node21=1 ; else node21=0;
if LAST_3M_AVG_ASSET_TOTAL_NEW  >= 2.50000    then node22=1 ; else node22=0;
if MOBILE_FIXED_DAYS_NEW  >= 4.50000    then node23=1 ; else node23=0;
if LAST_1M_AVG_ASSET_TOTAL_NEW  >= 2.50000    then node24=1 ; else node24=0;
if ACTIVITY_AREA_STABILITY_NEW  >= 1.50000    then node25=1 ; else node25=0;
if XFDC_INDEX_NEW  >= 1.50000    then node26=1 ; else node26=0;
if PRE_1Y_PAY_CNT_NEW  >= 4.50000    then node27=1 ; else node27=0;
if AUTH_FIN_LAST_1M_CNT_NEW  >= 4.50000    then node28=1 ; else node28=0;
if CONSUME_STEADY_BYXS_1Y_NEW  >= 1.50000    then node29=1 ; else node29=0;
if HAVE_CAR_FLAG_NEW  >= 1.50000    then node30=1 ; else node30=0;
if AVG_PUC_SDM_LAST_1Y_NEW  >= 1.50000    then node31=1 ; else node31=0;
if AUTH_FIN_LAST_3M_CNT_NEW  >= 4.50000    then node32=1 ; else node32=0;
if OVD_ORDER_AMT_1M_NEW  >= 1.50000    then node33=1 ; else node33=0;
if OVD_ORDER_CNT_1M_NEW  >= 1.50000    then node34=1 ; else node34=0;
if AUTH_FIN_LAST_6M_CNT_NEW  >= 2.50000    then node35=1 ; else node35=0;
if OVD_ORDER_CNT_3M_NEW  >= 1.50000    then node36=1 ; else node36=0;
if OVD_ORDER_AMT_3M_NEW  >= 1.50000    then node37=1 ; else node37=0;
if OVD_ORDER_CNT_3M_M1_STATUS = N    then node38=1 ; else node38=0;
if HAVE_FANG_FLAG_NEW  >= 1.50000    then node39=1 ; else node39=0;
if OVD_ORDER_AMT_6M_NEW  >= 1.50000    then node40=1 ; else node40=0;
if OVD_ORDER_CNT_6M_NEW  >= 1.50000    then node41=1 ; else node41=0;
if OVD_ORDER_CNT_6M_M1_STATUS= N    then node42=1 ; else node42=0;
if OVD_ORDER_CNT_12M_NEW  >= 7.50000    then node43=1 ; else node43=0;
if OVD_ORDER_CNT_12M_M3_STATUS= N    then node44=1 ; else node44=0;
if OVD_ORDER_CNT_2Y_M3_STATUS= N    then node45=1 ; else node45=0;
if OVD_ORDER_CNT_12M_M1_STATUS= N    then node46=1 ; else node46=0;
if OVD_ORDER_CNT_5Y_M3_STATUS= N    then node47=1 ; else node47=0;
if OVD_ORDER_AMT_12M_NEW  >= 1.50000    then node48=1 ; else node48=0;
if USE_MOBILE_2_CNT_1Y_NEW  >= 2.50000    then node49=1 ; else node49=0;
if OVD_ORDER_CNT_12M_M6_STATUS= N    then node50=1 ; else node50=0;
if OVD_ORDER_CNT_5Y_M6_STATUS= Y    then node51=1 ; else node51=0;
if OVD_ORDER_CNT_2Y_M6_STATUS  = Y    then node52=1 ; else node52=0;

run;

options mprint;

%let input=node1
node2
node3
node4
node5
node6
node7
node8
node9
node10
node11
node12
node13
node14
node15
node16
node17
node18
node19
node20
node21
node22
node23
node24
node25
node26
node27
node28
node29
node30
node31
node32
node33
node34
node35
node36
node37
node38
node39
node40
node41
node42
node43
node44
node45
node46
node47
node48
node49
node50
node51
node52;


%macro cxq_char(varname=);
%do i=1 %to 51 ;
%do j=%eval(&i+1) %to 52;
%let a=%scan(&varname,&i);
%let b=%scan(&varname,&j);

proc means data = das.das_double_var  noprint nway;
class &a &b  ;
var is_due is_late is_due_5 is_late_5 is_due_10 is_late_10;
output out=a_&i._&j.  sum=sum_due sum_late sum_due_5 sum_late_5 sum_due_10 sum_late_10;


data b_&i._&j.;
set a_&i._&j;
length var_name1 $100. var_name2 $100.;
var_name1="&a.";
var_name2="&b";

varname1=&a;
varname2=&b;

drop &a &b;
run;
proc append base=das.result_char data=b_&i._&j  force;
run;

%end;

%end;


%mend;

%cxq_char(varname=&input.);
